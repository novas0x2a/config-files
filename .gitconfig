[user]
    name = Mike Lundy
    email = mike@fluffypenguin.org
[color]
    diff = auto
    status = auto
    branch = auto
    interactive = auto
    ui = auto
[filter "remove-password"]
    clean=bin/hooks/filter-password
[filter "remove-token"]
    clean=bin/hooks/filter-token
[github]
    user = novas0x2a
[sendemail]
    suppressfrom = true
[merge]
    tool = vimdiff
    #ff = only
[svn]
    rmdir = true
[rerere]
    enabled = true
[alias]
    # Console gitview replacement
    lg = log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cd)%Creset' --abbrev-commit --date=relative

    # Find the best name for the current branch
    current-branch = !"f() { branch_name=$(git symbolic-ref -q HEAD); branch_name=${branch_name##refs/heads/}; branch_name=${branch_name:-HEAD}; echo $branch_name; }; f"

    # Given a commit id, does an svn dcommit on that commit and parents. Doesn't use git checkout - because dcommit can change branches.
    svn-push-cherry = !"f() { set -x; safe=__safe-$RANDOM; current=$(git current-branch); git svn rebase && git checkout -b $safe $1 && git svn dcommit && git checkout ${current} && git svn rebase && git branch -d $safe; set +x; }; f"

    # Some short versions
    s = status
    ap = add -p
    ri = rebase --interactive

    # Show absolute top of repo
    top = !"(cd \"`git rev-parse --git-dir`\" && cd .. && pwd)"

    pruneall = !"f() { for remote in $(git remote); do echo \"pruning $remote\"; git remote prune $remote $*; done }; f"

    # These svn ones don't work yet
    ## Get path to my externals file
    #svn-ext-file = !"echo `git top`/.git/svn/my-externals.txt"

    ## Update one svn repo
    #svn-ext-updateone = !"f() { dir=\"`git top`/$1\"; test -d $dir && svn update $dir || svn checkout $2 $dir; }; f"

    ## Run a script on every external
    #svndo2 = !"f() { while read ext; do eval \"$1 $ext\" || return 1; done < `git svn-ext-file`; }; f"
    #svndo  = !"f() { while read ext; do path=`echo $ext | awk '{print $1}'`; set -x; $* ${path#/}; if [ $? -eq 0 ]; then set +x; else set +x; return 1; fi; done < `git svn-ext-file`; }; f"

    ## Update externals file
    #svn-ext-new  = !"f() { fn=`git svn-ext-file`; git svn show-externals | grep '^/' > $fn.2; test -f $fn && diff -u $fn $fn.2 || mv $fn.2 $fn; }; f"

    # Update all externals
    # svn-ext-update  = !"f() { set -x; fn=`git svn-ext-file`; git svn show-externals | grep '^/' > $fn.2; if ! diff -q $fn $fn.2; then mv $fn.2 $fn; if ! git svndo git-svn-ext-updateone; then rm $fn; return 1; fi; fi; }; f"

    # Doesn't work :(
    # ignore = !"f() { for i in \"$@\"; do echo $(basename $i) >> $(dirname $i)/.gitignore; done; }; f"

    # getdate  = !"f() { a=$(git log --pretty='format:%ad' ${1}~1..${1} | head -n1); echo $a; }; f"
    fromdate = !"f() { a=$(git log --all --pretty='format:%H' --until=\"@{${1}}\" | head -n1); echo $a; }; f"
    pushv    = !"f() { git push -vvvn \"$@\" && echo -n '\nok (y/N)? ' && read ok && test x\"$ok\" = 'xy' && echo git push -vvv \"$@\" || echo 'skipping push'; }; f"
    date = log --pretty='format:%ad'

    rebase-prep = !"f() { git rebase -i $(git merge-base HEAD $1); }; f"

    prune-remote-helper = !"f() { git branch -a --merged ${2:+$2}  | grep remotes/${1:?[\nusage: git prune-remote <remote> [branch]]}/ | cut -d / -f 3- | grep -v '^master$'; }; f"
    prune-remote-pretend = !"f() { git prune-remote-helper $* | xargs git push --delete -n $1; }; f"
    prune-remote = !"f() { git prune-remote-helper $* | xargs git push --delete $1; }; f"

    review = !sh `git rev-parse --show-toplevel`/tools/rfc.sh

    since-last-merge = !"f() { git log -p --reverse $(git merge-base ${1:?[git since-last-merge <oldbranch> <newbranch>} ${2:?[git since-last-merge <oldbranch> <newbranch>]})..$2; }; f"

    oldbranches = for-each-ref --sort='-authordate' --format='%(authordate:iso8601) %(refname:short)' refs/heads
    savage-sequence          = !"f() { git test-sequence ${1:-piston/master}..${2:-HEAD} 'savage/install-packages.sh && savage/run_tests.py -1'; }; f"
    savage-sequence-all      = !"f() { git test-sequence ${1:-piston/master}..${2:-HEAD} 'savage/install-packages.sh && savage/run_tests.py'; }; f"
    savage-sequence-all-lint = !"f() { git test-sequence ${1:-piston/master}..${2:-HEAD} 'savage/install-packages.sh && savage/run_tests.py && pylint --rcfile=savage/.pylintrc savage/savage savage/tests'; }; f"
    savage-sequence-force    = !"f() { git test-sequence --force ${1:-piston/master}..${2:-HEAD} 'savage/install-packages.sh && savage/run_tests.py -1'; }; f"
    savage-sequence-lint     = !"f() { git test-sequence ${1:-piston/master}..${2:-HEAD} 'savage/install-packages.sh && savage/run_tests.py -1 && pylint --rcfile=savage/.pylintrc savage/savage savage/tests'; }; f"
    testit                   = !"f() { git savage-sequence-all-lint 2>&1 | tee savage/testit.log; }; f"
    delete-merged-remotes    = !"f() { OWNER=${1:-novas0x2a}; BRANCHES=$(git branch -r --merged ${2:-piston/master} | grep $OWNER | grep -v master | cut -d / -f 2- --output-delimiter=/); [[ -z $BRANCHES ]] && exit 0; echo git push --delete $OWNER $BRANCHES; read -p 'Okay? ' -n 1 -r; echo; if [[ -n $BRANCHES ]] && [[ $REPLY = y ]]; then git push --delete $OWNER $BRANCHES; fi; }; f"
    maybe-merged = !"f() { PARENT=${1:-piston/master}; for branch in $(git for-each-ref --format='%(refname)' refs/heads | grep -v '/master$'); do if git cherry \"$PARENT\" \"$branch\" | grep -q '^-'; then echo \"$branch\"; fi; done; }; f"


[log]
    date = local
[push]
    default = simple
[core]
    excludesfile = ~/.gitexcludes
[branch]
    autosetuprebase = always
[gitreview]
    username = novas0x2a
[diff]
    algorithm = histogram
[gc]
    reflogexpire = never
    reflogexpireunreachable = never
    auto = 0
